<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analytics Results</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script> <!-- Plugin for labels -->
  <style>
  body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      background-image: linear-gradient(white, rgb(122, 166, 232));
      padding-top: 60px;
    }
    nav {
      background-color: hsl(198, 87%, 50%);
      width: 100%;
      padding: 10px 20px;
      color: white;
      /* Remove text-align center to use flexbox */
      /* text-align: center; */
      font-size: 20px;
      font-weight: bold;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 60px; /* enough height for two lines */
      box-sizing: border-box;
    }

    .analytics-container {
      display: flex;
      flex-direction: row;
      justify-content: center; /* center the containers horizontally */
      align-items: center;
      padding: 20px 15px;
      gap: 30px;
      flex-wrap: nowrap;
      margin-top: 20px;
      max-height: 700px;
      height: 700px;
      width: 100%;
      box-sizing: border-box;
    }
    .analytics-left {
      background: linear-gradient(to bottom right, #c3e0f7, #a3c9f9);
      border-radius: 15px;
      padding: 20px 15px;
      width: 50%;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      height: 100%;
      overflow-y: auto;
      box-sizing: border-box;
    }
      .analytics-right {
        width: 50%;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        border-radius: 15px;
        background: linear-gradient(to bottom right, #c3e0f7, #a3c9f9);
        padding: 20px 15px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-start;
        height: 100%;
        max-width: 600px;
        overflow-x: hidden;
        overflow-y: auto;
        box-sizing: border-box;
      }
    .analytics-right canvas {
      width: 100% !important;
      height: auto !important;
      border-radius: 15px;
      max-height: 100%;
    }

    .analytics-left h2 {
      font-size: 36px;
      background: #b7d9f7;
      padding: 14px 28px;
      border-radius: 25px;
      display: inline-block;
      font-weight: 900;
    }

    button {
      display: block;
      margin: 24px auto;
      text-align: center;
      padding: 14px 28px;
      font-size: 18px;
      font-weight: 600;
    }

    .description {
      background: #9cc0e5;
      padding: 24px;
      border-radius: 15px;
      margin: 24px 0;
      color: #001933;
      font-size: 18px;
    }

    .legend {
      margin: 20px 0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 14px 0;
      font-size: 18px;
      font-weight: 600;
    }

    .legend-color {
      width: 25px;
      height: 25px;
      margin-right: 10px;
      border-radius: 4px;
    }

    .green {
      background-color: #12c468;
    }

    .red {
      background-color: #f44336;
    }

    .cta-box {
      background: #9cc0e5;
      padding: 20px;
      border-radius: 15px;
    }

    .cta-box p {
      margin-bottom: 15px;
      font-weight: bold;
      color: #001933;
    }

    .cta-box button {
      background-color: #1e90ff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      cursor: pointer;
    }

    .cta-box button:hover {
      background-color: #0b6fc2;
    }

    @media (max-width: 900px) {
      .analytics-container {
        flex-direction: column;
        max-height: none;
        height: auto;
      }

      .analytics-left,
      .analytics-right {
        width: 100%;
        max-width: 100%;
        height: auto;
      }
    }

    @media (max-width: 600px) {
      .analytics-container {
        padding: 15px;
      }
      .analytics-left {
        padding: 15px;
        width: 100%;
      }
      .cta-box {
        padding: 15px;
      }
      button {
        width: 100%;
        padding: 12px 0;
        font-size: 16px;
      }
      .analytics-left h2 {
        font-size: 28px;
        padding: 10px 20px;
      }
      .description {
        font-size: 16px;
        padding: 15px;
      }
      .legend-item {
        font-size: 16px;
      }
    }

    @media (max-width: 400px) {
      nav {
        font-size: 16px;
        padding: 15px;
      }
      .analytics-left h2 {
        font-size: 24px;
        padding: 8px 16px;
      }
      button {
        font-size: 14px;
        padding: 10px 0;
      }
      .description {
        font-size: 14px;
      }
      .legend-item {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
    <nav>
      <div><button onclick="window.history.back()" style="background:none; border:none; color:white; font-size:18px; cursor:pointer;">&#8592; Back</button></div>
      <div id="dateTime" style="text-align: right; white-space: nowrap; overflow: visible; min-width: 200px;">
      </div>
    </nav>
    <div class="analytics-container">
      <div class="analytics-left" style="max-height: 550px; overflow-y: auto;">
        <h2>ANALYTICS RESULTS</h2>

        <div class="description" id="demographicsDescription">
          Loading demographics...
        </div>

        <div class="cta-box">
          <p>DO YOU WANT TO SEE THE RESULTS AND SUGGESTIONS PER AREA?</p>
          <button onclick="window.location.href='map.html'">CLICK HERE!</button>
        </div>
      </div>

      <div class="analytics-right" style="flex-direction: column; gap: 20px; overflow-y: auto; max-height: 550px; max-width: 600px; padding-right: 10px;">
       
        <div id="genderChartContainer" style="height: 180px; margin-top: 40px; margin-bottom: 20px; flex-shrink: 0; width: 100%;">
          <canvas id="genderChart" style="width: 100%; max-width: 600px;"></canvas>
        </div>
        <div id="ageChartContainer" style="height: 220px; margin-top: 40px; flex-shrink: 0; width: 100%;">
          <canvas id="ageChart" style="width: 100%; max-width: 600px;"></canvas>
        </div>
      </div>
    </div>

  <script>
    // Simple K-means clustering implementation in JS
    function kMeans(data, k, maxIterations = 100) {
      // Initialize centroids randomly from data points
      let centroids = [];
      const usedIndices = new Set();
      while (centroids.length < k) {
        const idx = Math.floor(Math.random() * data.length);
        if (!usedIndices.has(idx)) {
          centroids.push(data[idx].slice());
          usedIndices.add(idx);
        }
      }

      let assignments = new Array(data.length).fill(-1);
      let iterations = 0;
      let changed = true;

      function distance(a, b) {
        let sum = 0;
        for (let i = 0; i < a.length; i++) {
          sum += (a[i] - b[i]) ** 2;
        }
        return Math.sqrt(sum);
      }

      while (changed && iterations < maxIterations) {
        changed = false;
        // Assign points to nearest centroid
        for (let i = 0; i < data.length; i++) {
          let minDist = Infinity;
          let minIndex = -1;
          for (let j = 0; j < k; j++) {
            const dist = distance(data[i], centroids[j]);
            if (dist < minDist) {
              minDist = dist;
              minIndex = j;
            }
          }
          if (assignments[i] !== minIndex) {
            assignments[i] = minIndex;
            changed = true;
          }
        }

        // Update centroids
        let sums = Array(k).fill(0).map(() => Array(data[0].length).fill(0));
        let counts = Array(k).fill(0);

        for (let i = 0; i < data.length; i++) {
          const cluster = assignments[i];
          counts[cluster]++;
          for (let d = 0; d < data[0].length; d++) {
            sums[cluster][d] += data[i][d];
          }
        }

        for (let j = 0; j < k; j++) {
          if (counts[j] === 0) continue; // avoid division by zero
          for (let d = 0; d < data[0].length; d++) {
            centroids[j][d] = sums[j][d] / counts[j];
          }
        }

        iterations++;
      }

      return { assignments, centroids };
    }

    // Map categorical data to numeric for clustering
    function encodeCategorical(value, categories) {
      return categories.indexOf(value);
    }

    // Extract features from surveyDataPoints for clustering
    function extractFeatures(dataPoints) {
      // We will use age, gender, address, and survey responses as features
      // For gender and address, encode as numeric categories
      // For survey responses, encode as numeric or count of positive answers

      const genders = ['Male', 'Female'];
      const addresses = [...new Set(dataPoints.map(dp => dp.registration?.address || 'Unknown'))];

      const features = [];
      dataPoints.forEach(dp => {
        const reg = dp.registration || {};
        const age = reg.age || 0;
        const gender = reg.gender || '';
        const address = reg.address || '';

        // Encode gender and address
        const genderNum = encodeCategorical(gender, genders);
        const addressNum = encodeCategorical(address, addresses);

        // For survey responses, count number of responses or average numeric values
        const responses = dp.responses || {};
        let responseValues = [];

        // Flatten responses values to numeric
        for (const key in responses) {
          const val = responses[key];
          if (Array.isArray(val)) {
            // For multiple choice, count number of selected options
            responseValues.push(val.length);
          } else {
            // Try to parse as number, else length of string
            const numVal = parseFloat(val);
            if (!isNaN(numVal)) {
              responseValues.push(numVal);
            } else if (typeof val === 'string') {
              responseValues.push(val.length);
            }
          }
        }

        // If no responses, add zero
        if (responseValues.length === 0) {
          responseValues.push(0);
        }

        // Combine all features into one array
        // age, genderNum, addressNum, ...responseValues
        features.push([age, genderNum, addressNum, ...responseValues]);
      });

      return features;
    }

    // Function to calculate and display overall gender and age distribution percentages
    function displayOverallDemographics(dataPoints) {
      if (dataPoints.length === 0) {
        return;
      }

      const genderCount = { Male: 0, Female: 0, Unknown: 0 };
      const ageGroups = {
        '18-24': 0,
        '25-34': 0,
        '35-44': 0,
        '45-54': 0,
        '55-64': 0,
        '65 and over': 0,
        'Unknown': 0
      };

      dataPoints.forEach(p => {
        const gender = p.registration.gender || 'Unknown';
        genderCount[gender] = (genderCount[gender] || 0) + 1;

        const age = p.registration.age;
        if (age === undefined || age === null || age === 0) {
          ageGroups['Unknown']++;
        } else if (age <= 24) {
          ageGroups['18-24']++;
        } else if (age <= 34) {
          ageGroups['25-34']++;
        } else if (age <= 44) {
          ageGroups['35-44']++;
        } else if (age <= 54) {
          ageGroups['45-54']++;
        } else if (age <= 64) {
          ageGroups['55-64']++;
        } else {
          ageGroups['65 and over']++;
        }
      });

      const total = dataPoints.length;

      // Calculate percentages
      const genderPercentages = {};
      for (const g in genderCount) {
        genderPercentages[g] = ((genderCount[g] / total) * 100).toFixed(1);
      }

      const agePercentages = {};
      for (const ag in ageGroups) {
        agePercentages[ag] = ((ageGroups[ag] / total) * 100).toFixed(1);
      }

      // Build HTML for display
      let demographicsHtml = '<h3>Overall Demographics:</h3>';

      demographicsHtml += '<strong>Gender Distribution:</strong><ul>';
      for (const g in genderPercentages) {
        demographicsHtml += `<li>${g}: ${genderPercentages[g]}%</li>`;
      }
      demographicsHtml += '</ul>';

      demographicsHtml += '<strong>Age Distribution:</strong><ul>';
      for (const ag in agePercentages) {
        demographicsHtml += `<li>${ag}: ${agePercentages[ag]}%</li>`;
      }
      demographicsHtml += '</ul>';
      demographicsHtml += '<p>Total Participants: ' + total + '</p>';
      if (typeof document !== 'undefined') {
        const descriptionDiv = document.getElementById('demographicsDescription');
        if (descriptionDiv) {
          descriptionDiv.innerHTML = demographicsHtml;
        }
      }
    }

    // Main function to load data, run clustering and visualize
    function runAnalysis() {
      try {
        const rawData = localStorage.getItem('surveyDataPoints');
        console.log('Raw surveyDataPoints from localStorage:', rawData);
        const surveyDataPoints = JSON.parse(rawData) || [];
        console.log('Parsed surveyDataPoints:', surveyDataPoints);

        if (!Array.isArray(surveyDataPoints) || surveyDataPoints.length === 0) {
          const descDiv = document.getElementById('demographicsDescription');
          if (descDiv) {
            descDiv.textContent = 'No survey data available for analysis.';
          }
          console.warn('No survey data available for analysis or data is not an array.');
          return;
        }

        displayOverallDemographics(surveyDataPoints);
        displayGenderBarChart(surveyDataPoints);
        displayAgeBarChart(surveyDataPoints);
      } catch (error) {
        console.error('Error in runAnalysis:', error);
        const descDiv = document.getElementById('demographicsDescription');
        if (descDiv) {
          descDiv.textContent = 'Error loading survey data.';
        }
      }
    }

    // Function to display gender bar chart
    function displayGenderBarChart(dataPoints) {
      if (dataPoints.length === 0) return;

      const genderCount = { Male: 0, Female: 0, Unknown: 0 };

      dataPoints.forEach(p => {
        const gender = p.registration.gender || 'Unknown';
        genderCount[gender] = (genderCount[gender] || 0) + 1;
      });

      // Prepare data for gender bar chart
      const genderLabels = Object.keys(genderCount);
      const genderData = genderLabels.map(g => genderCount[g]);

      // Destroy previous chart if exists
      if (window.genderChartInstance) {
        window.genderChartInstance.destroy();
      }

      const ctx = document.getElementById('genderChart').getContext('2d');

      window.genderChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: genderLabels,
          datasets: [{
            label: 'Count',
            data: genderData,
            backgroundColor: ['#12c468', '#f44336', '#999999'] // gender colors
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                stepSize: 1
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            datalabels: {
              anchor: 'end',
              align: 'top',
              color: '#000',
              font: {
                weight: 'bold'
              }
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Function to display age bar chart
    function displayAgeBarChart(dataPoints) {
      if (dataPoints.length === 0) return;

      const ageGroups = {
        '18-24': 0,
        '25-34': 0,
        '35-44': 0,
        '45-54': 0,
        '55-64': 0,
        '65 and over': 0,
        'Unknown': 0
      };

      dataPoints.forEach(p => {
        const age = p.registration.age;
        if (age === undefined || age === null || age === 0) {
          ageGroups['Unknown']++;
        } else if (age <= 24) {
          ageGroups['18-24']++;
        } else if (age <= 34) {
          ageGroups['25-34']++;
        } else if (age <= 44) {
          ageGroups['35-44']++;
        } else if (age <= 54) {
          ageGroups['45-54']++;
        } else if (age <= 64) {
          ageGroups['55-64']++;
        } else {
          ageGroups['65 and over']++;
        }
      });

      // Prepare data for age bar chart
      const ageLabels = Object.keys(ageGroups);
      const ageData = ageLabels.map(ag => ageGroups[ag]);

      // Destroy previous chart if exists
      if (window.ageChartInstance) {
        window.ageChartInstance.destroy();
      }

      const ctx = document.getElementById('ageChart').getContext('2d');

      window.ageChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ageLabels,
          datasets: [{
            label: 'Count',
            data: ageData,
            backgroundColor: ['#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#c9cbcf', '#8e5ea2', '#8e5ea2'] // age colors
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                stepSize: 1
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            datalabels: {
              anchor: 'end',
              align: 'top',
              color: '#000',
              font: {
                weight: 'bold'
              }
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      runAnalysis();
    });
  </script>
  <script>
    function updateDateTime() {
      const now = new Date();
      const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
      const dateStr = now.toLocaleDateString(undefined, options);
      const timeStr = now.toLocaleTimeString(undefined, {hour: '2-digit', minute: '2-digit', second: '2-digit'});
      document.getElementById('dateTime').innerHTML = dateStr + '<br>' + timeStr;
    }

    setInterval(updateDateTime, 1000);
    updateDateTime();
  </script>
</body>
</html>
